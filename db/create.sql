-- Feel free to modify this file to match your development goal.
-- Here we only create 3 tables for demo purpose.

Create Table User(
	UID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	email VARCHAR(256) UNIQUE NOT NULL,
	pwd VARCHAR(256) NOT NULL,
	address VARCHAR (256)NOT NULL,
	firstname VARCHAR(256) NOT NULL,
	lastname VARCHAR(256) NOT NULL,
	balance INTEGER NOT NULL,
	is_seller VARCHAR(1) NOT NULL
);

CREATE TABLE Category (
    cat_name VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE Products (
	product_name VARCHAR(255) NOT NULL,
	product_id INT UNIQUE NOT NULL PRIMARY KEY,
	product_description VARCHAR(255) NOT NULL,
	image_id VARCHAR(255) NOT NULL,
    price FLOAT NOT NULL,
	link VARCHAR(255) NOT NULL,
	UID REFERENCES User(UID),
	quantity FLOAT NOT NULL,
    available VARCHAR(1) NOT NULL
);

CREATE TABLE product_review(
    review_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    UID INTEGER NOT NULL REFERENCES User,
    product_id INTEGER NOT NULL REFERENCES Products,
    rev_timestamp TIMESTAMP without time zone NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC')
    rating INTEGER NOT NULL,
    review VARCHAR(100) NOT NULL, UNIQUE(uid, product_id)
);

CREATE TABLE Orders(
   user REFERENCES User(UID) PRIMARY KEY,
   prod REFERENCES Products(product_id) PRIMARY KEY,
   order _quantity INTEGER NOT NULL,
   Date INTEGER default NULL
);









CREATE FUNCTION TF_email() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT * FROM User
	WHERE NEW.email = User.email)
	THEN
	RAISE EXCEPTION ‘Email already in use’;
	END IF;

	RETURN NEW;
END;

$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_email
	BEFORE INSERT OR UPDATE ON User
	FOR EACH ROW
	EXECUTE PROCEDURE TF_email();

CREATE FUNCTION TF_balance() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT * FROM User
	WHERE balance < 0)
	THEN
	RAISE EXCEPTION ‘Balance cannot fall below 0’;
	END IF;

	RETURN NEW;
END;

$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_balance
	BEFORE INSERT OR UPDATE ON User
	FOR EACH ROW
	EXECUTE PROCEDURE TF_balance();

CREATE FUNCTION TF_systemid() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT * FROM User
	WHERE new.UID <> User.UID)
	THEN
	RAISE EXCEPTION ‘Cannot update System ID’;
	END IF;

	RETURN NEW;
END;

$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_systemid
	BEFORE UPDATE ON User
	FOR EACH ROW
	EXECUTE PROCEDURE TF_systemid();
CREATE FUNCTION TF_seller() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT * FROM User
	WHERE new.is_seller <> ‘Y’ or new.is_seller <> ’N’)
	THEN
	RAISE EXCEPTION ‘is_seller must be Y or N’;
	END IF;

	RETURN NEW;
END;

$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_seller
	BEFORE INSERT OR UPDATE ON User
	FOR EACH ROW
	EXECUTE PROCEDURE TF_seller();


CREATE VIEW PersonalInformation (?) AS
SELECT UID, firstname, lastname, 
(SELECT 
(CASE WHEN seller==’yes’ 
THEN email, address, 
(SELECT * FROM reviews WHERE reviews.UID=user.UID)
ELSE balance END)
FROM User, reviews where user.UID=reviews.sellerid;

--to ensure the user trying to write review has purchased this product
CREATE FUNCTION TF_NewReview() RETURNS TRIGGER AS $$
BEGIN
  IF NOT EXISTS (SELECT * FROM orders_fulfilled
   WHERE product_id = NEW.product_id AND uid = NEW.uid
   THEN                       
  RAISE EXCEPTION 'user % has not ordered product', uid
  ;

  END IF;

$$ LANGUAGE plpgsql;

CREATE TRIGGER UserHasNotPurchased
  BEFORE INSERT OR UPDATE ON product_review
  FOR EACH ROW
  EXECUTE PROCEDURE TF_NewReview();


--to ensure user trying to edit review matches user that wrote it:
CREATE FUNCTION TF_EditReview() RETURNS TRIGGER AS $$
BEGIN
  IF NOT EXISTS (SELECT * FROM product_review
   WHERE uid = NEW.uid
   THEN                       
  RAISE EXCEPTION 'user does not match original author'
  ;

  END IF;

$$ LANGUAGE plpgsql;

CREATE TRIGGER UserCannotEdit
  BEFORE UPDATE ON product_review
  FOR EACH ROW
  EXECUTE PROCEDURE TF_EditReview();





